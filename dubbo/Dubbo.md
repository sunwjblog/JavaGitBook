# Dubbo

#### 什么是RPC？

RPC（Remote Procedure Call）即远程过程调用，所以RPC关注的是远程调用而不是本地调用。

**我们为什么在开发过程中使用RPC？**因为两个不同的服务器上的服务提供的方法不在一个内存空间上，所以就要通过网络编程的方式调用所需要的方法。方法调用的结果也是需要通过网络编程来接收。

如果这个过程需要我们自己动手来编写网络程序实现这个调用过程的话，那我们的工作量会巨大，因为我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。

RPC可以帮助我们调用远程计算机上的某个服务的某个方法，这个过程就像我们在本地调用方法一样方便。我们不需要考虑它的底层方式是怎么样的，拿来即用。

#### RPC的工作原理

RPC的核心功能可以分为以下几个部分：

* **客户端（服务消费端）** ：调用远程方法的一端。

* **客户端 Stub（桩）** ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。

* **网络传输** ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。

* **服务端 Stub（桩）** ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。

* **服务端（服务提供端）** ：提供远程方法的一端。

  ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/RPC原理.png)

  ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/dubbo原理时序图.png)

整个过程分析：

1. 服务消费端：以本地调用的方式调用远程服务；
2. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：`RpcRequest`；
3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
4. 服务端 Stub（桩）收到消息将消息反序列化为Java对象: `RpcRequest`；
5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；
6. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：`RpcResponse`（序列化）发送至消费方；
7. 客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:`RpcResponse` ，这样也就得到了最终结果。over!

#### Dubbo基础

##### [什么是Dubbo？](https://dubbo.apache.org/zh/)

Dubbo官方文档介绍，Dubbo提供了六个核心能力：

![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/Dubbo核心能力.png)

1. 面向接口代理的高性能RPC调用。
2. 智能容错和负载均衡。
3. 服务自动注册和发现。
4. 高度可扩展能力。
5. 运行期流量调度。
6. 可视化的服务治理与运维。

#### Dubbo的基本概念

![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/Dubbo的组成结构.png)

1. ##### 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。

2. ##### 服务消费者（Consumer)：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。

3. ##### 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者

4. ##### 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心

5. ##### 启动容器（Container）

##### 调用关系解释：

*  服务容器负责启动，加载，运行服务提供者。
*  服务提供者在启动时，向注册中心注册自己提供的服务。
*  服务消费者在启动时，向注册中心订阅自己所需的服务。
*  注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
*  服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
* 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

#### Dubbo的好处

随着互联网的发展，网站的规模越来越大，用户数量越来越多。单一应用架构 、垂直应用架构无法满足我们的需求，这个时候分布式服务架构就诞生了。

分布式服务架构下，系统被拆分成不同的服务比如短信服务、安全服务，每个服务独立提供系统的某个核心服务。

Dubbo可以帮助我们解决什么问题？

1. **负载均衡** ： 同一个服务部署在不同的机器时该调用那一台机器上的服务。

2. **服务调用链路生成** ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。

3. **服务访问压力以及时长统计、资源调度和治理** ：基于访问压力实时管理集群容量，提高集群利用率。

4. ......

   ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/Dubbo服务治理.png)

#### Dubbo 的工作原理

![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/Dubbo原理图.jpeg)

*左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口*，位于中轴线上的为双方都用到的接口。

- **config 配置层**：Dubbo相关的配置。支持代码配置，同时也支持基于 Spring 来做配置，以 `ServiceConfig`, `ReferenceConfig` 为中心
- **proxy 服务代理层**：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 `ServiceProxy` 为中心。
- **registry 注册中心层**：封装服务地址的注册与发现。
- **cluster 路由层**：封装多个提供者的路由及负载均衡，并桥接注册中心，以 `Invoker` 为中心。
- **monitor 监控层**：RPC 调用次数和调用时间监控，以 `Statistics` 为中心。
- **protocol 远程调用层**：封装 RPC 调用，以 `Invocation`, `Result` 为中心。
- **exchange 信息交换层**：封装请求响应模式，同步转异步，以 `Request`, `Response` 为中心。
- **transport 网络传输层**：抽象 mina 和 netty 为统一接口，以 `Message` 为中心。
- **serialize 数据序列化层** ：对需要在网络传输的数据进行序列化。

#### Dubbo的负载均衡策略

