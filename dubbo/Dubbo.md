# Dubbo

#### 什么是RPC？

RPC（Remote Procedure Call）即远程过程调用，所以RPC关注的是远程调用而不是本地调用。

**我们为什么在开发过程中使用RPC？**因为两个不同的服务器上的服务提供的方法不在一个内存空间上，所以就要通过网络编程的方式调用所需要的方法。方法调用的结果也是需要通过网络编程来接收。

如果这个过程需要我们自己动手来编写网络程序实现这个调用过程的话，那我们的工作量会巨大，因为我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。

RPC可以帮助我们调用远程计算机上的某个服务的某个方法，这个过程就像我们在本地调用方法一样方便。我们不需要考虑它的底层方式是怎么样的，拿来即用。

#### RPC的工作原理

RPC的核心功能可以分为以下几个部分：

* **客户端（服务消费端）** ：调用远程方法的一端。

* **客户端 Stub（桩）** ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。

* **网络传输** ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。

* **服务端 Stub（桩）** ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。

* **服务端（服务提供端）** ：提供远程方法的一端。

  ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/RPC原理.png)

  ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/dubbo原理时序图.png)

整个过程分析：

1. 服务消费端：以本地调用的方式调用远程服务；
2. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：`RpcRequest`；
3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
4. 服务端 Stub（桩）收到消息将消息反序列化为Java对象: `RpcRequest`；
5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；
6. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：`RpcResponse`（序列化）发送至消费方；
7. 客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:`RpcResponse` ，这样也就得到了最终结果。over!

#### Dubbo基础

##### [什么是Dubbo？](https://dubbo.apache.org/zh/)

Dubbo官方文档介绍，Dubbo提供了六个核心能力：

![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/Dubbo核心能力.png)

1. 面向接口代理的高性能RPC调用。
2. 智能容错和负载均衡。
3. 服务自动注册和发现。
4. 高度可扩展能力。
5. 运行期流量调度。
6. 可视化的服务治理与运维。

#### Dubbo的基本概念

![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/Dubbo的组成结构.png)

1. ##### 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。

2. ##### 服务消费者（Consumer)：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。

3. ##### 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者

4. ##### 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心

5. ##### 启动容器（Container）

##### 调用关系解释：

*  服务容器负责启动，加载，运行服务提供者。
*  服务提供者在启动时，向注册中心注册自己提供的服务。
*  服务消费者在启动时，向注册中心订阅自己所需的服务。
*  注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
*  服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
* 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

#### Dubbo的好处

随着互联网的发展，网站的规模越来越大，用户数量越来越多。单一应用架构 、垂直应用架构无法满足我们的需求，这个时候分布式服务架构就诞生了。

分布式服务架构下，系统被拆分成不同的服务比如短信服务、安全服务，每个服务独立提供系统的某个核心服务。

Dubbo可以帮助我们解决什么问题？

1. **负载均衡** ： 同一个服务部署在不同的机器时该调用那一台机器上的服务。

2. **服务调用链路生成** ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。

3. **服务访问压力以及时长统计、资源调度和治理** ：基于访问压力实时管理集群容量，提高集群利用率。

4. ......

   ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/Dubbo服务治理.png)

#### Dubbo 的工作原理

![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/Dubbo原理图.jpeg)

*左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口*，位于中轴线上的为双方都用到的接口。

- **config 配置层**：Dubbo相关的配置。支持代码配置，同时也支持基于 Spring 来做配置，以 `ServiceConfig`, `ReferenceConfig` 为中心
- **proxy 服务代理层**：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 `ServiceProxy` 为中心。
- **registry 注册中心层**：封装服务地址的注册与发现。
- **cluster 路由层**：封装多个提供者的路由及负载均衡，并桥接注册中心，以 `Invoker` 为中心。
- **monitor 监控层**：RPC 调用次数和调用时间监控，以 `Statistics` 为中心。
- **protocol 远程调用层**：封装 RPC 调用，以 `Invocation`, `Result` 为中心。
- **exchange 信息交换层**：封装请求响应模式，同步转异步，以 `Request`, `Response` 为中心。
- **transport 网络传输层**：抽象 mina 和 netty 为统一接口，以 `Message` 为中心。
- **serialize 数据序列化层** ：对需要在网络传输的数据进行序列化。

#### Dubbo的负载均衡策略

##### 负载均衡

在系统中的某个服务的访问量过大时，我们将这个服务部署多套到服务器上，当用户发起请求的时候，多台服务器都可以处理这个请求。这个时候，如何均匀的正确的处理这些请求到服务器上很重要。

例如，我们要一台服务器来处理该服务的请求，那么该服务部署在多台服务器上就没有意义了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、奔溃等问题。

##### 负载均衡策略

* ##### Random LoadBalance（权重随机选择）

  按权重设置随机概率。

  在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

  实现原理，假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。

  我们把这些权重值分布在坐标区间会得到：S1->[0, 7) ，S2->(7, 10]。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。

* ##### RoundRobin LoadBalance（轮询）

  轮循，按公约后的权重设置轮循比率。

  存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

  其原理是，比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。如果我们有 10 次请求，那么 7 次会被 S1处理，3次被 S2处理。

* ##### LeastActive LoadBalance（最少活跃调用数）

  最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。

  使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

  初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。

  因此，**Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。**

  如果有多个服务提供者的活跃数相等的话，则在进行一次随机选择算法。

* ##### ConsistentHash LoadBalance（一致性Hash）

  一致性 Hash，相同参数的请求总是发到同一提供者。

  当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing

  缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key="hash.arguments" value="0,1" />

  缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key="hash.nodes" value="320" />

  ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/DubboHash一致性.png)

如图所示，Dubbo这样很容易发生数据倾斜的问题（节点不够分散，大量请求落到同一个节点上），Dubbo为了避免这种数据倾斜的问题，引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。

![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/DubboHash虚拟节点.png)

#### Dubbo实战

