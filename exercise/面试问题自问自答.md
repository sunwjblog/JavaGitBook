# 刻意练习

[toc]

## 多线程

### 当提交一个线程任务时，线程池是如何工作的？

问题拆解两部分回答此问题，线程池的参数构成；提交线程任务后参数的变化影响线程工作流程是怎样的。

1. 线程池的核心参数有：核心线程数、最大线程数、空闲线程存活时间、时间单位、任务队列、线程工厂、拒绝策略等参数；

2. 其中核心参数的设置，根据并发任务是什么类型的，如果是cpu密集型任务，则分配核心线程数为N+1；如果是I/O密集型的任务，则分配核心线程数为2N

3. 当提交一个线程任务时

   1. 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。
   2. 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。
   3. 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
   4. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
   5. 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

   ![](../image/任务调度流程图.png)

## JVM

### 类的加载过程是怎么样的？

1. 类的加载过程：加载、链接、初始化、使用、卸载，其中链接又分为 验证、验证、分析三个步骤
2. 加载：在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口
3. 验证：文件格式验证、元数据验证、字节码验证、符号引用验证
4. 准备：**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配
5. 分析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。
6. 初始化：初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。
7. 卸载：Class对象被GC

### 方法区和永久代的关系

在不同的JVM上方法区的实现肯定是不同的。**方法区和永久代的关系就像Java中的接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。**也就是说，永久代时HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

### 垃圾回收过程

JVM的垃圾回收采用的是分代回收算法，年轻代采用复制算法，老年代采用标记整理算法。因为年轻代频繁出发垃圾回收动作，采用复制算法可以提高垃圾回收效率。

年轻代又分为Eden区、Survivor0区和Survivor1区，它们之间的比例为8:1:1，每次垃圾回收时使用Eden区和其中一个Survivor区进行垃圾回收，大部分对象都是在Eden区生成，当创建新对象时，Eden区申请失败时（也就是空间不足时），触发一次GC，将Eden区存活的对象，复制到Survivor0区，然后清空Eden区，当Survivor0区也存满时，则将Eden区和Survivor0区的存活对象复制到Survivor1区，然后清空Eden区和Survivor0区，此时需要将Survivor0和Survivor1区进行互换，时刻保持Survivor1区为空的状态。

**为什么需要保持其中一个Survivor区为空？**是为了解决数据碎片化的问题。比如年轻代分为Eden区和Survivor区两个部分，一旦Eden区满后，触发GC，Eden区存活的对象迁移到Survivor区。这样继续循环下去，下一次Eden区再次满了，触发GC，这是Eden区和Survivor区都有存活的对象，如果硬把Eden区的对象放到Survivor区，这时候两部分对象所占有的内存是不连续的，也就导致了内存碎片化。

### 对象不可达GC Root一定就要回收吗？

对象不可达GC Roots不一定就被回收掉，因为一个对象的真正死亡是至少要经历两次标记过程。

* 第一次标记过程，发现对象没有与GC Roots的引用链，那对象第一次被标记并进行对象是否有必要执行finalize()方法与否条件筛选。当对象没有覆盖finalize()方法，或者finalize()方法没有被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
* 如果对象被判定有必要执行finalize()方法，则会将对象存入到F-Queue的队列，稍后由虚拟机的Finalizer线程去执行。
* 第二次标记过程，在执行finalize()方法之前，GC会对F-Queue队列中的对象进行第二次小规模标记，如果对象重新与GC Roots引用链建立连接，则会被移除“即将回收”的集合，如果对象这时候，仍然没有与GC Roots引用链建立连接，那它将会被真正的回收。

### 在谈引用

* **强引用** 就是指在程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不回回收掉被引用的对象。
* **软引用** 是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
* **弱引用** 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
* **虚引用** 也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不回对其生存事件构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 熟悉的垃圾回收器

* Serial 收集器
* ParNew收集器
* Parallel Scavenge收集器
* CMS收集器
* G1收集器

#### 常用的垃圾回收器

##### CMS 收集器

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/CMS收集器.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

##### G1 收集器

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

## Spring框架

### Spring如何解决循环依赖的？

Spring通过将实例化后的对象提前暴露给Spring容器中的singletonFactories，解决了循环依赖的问题。

具体实现是通过Spring初始化bean的时候，会经过三个缓存Map来存放bean，它们分别是：

* singletonObjects里面存放的是初始化之后的单例对象。
* earlySingletonObjects中存放的是一个已完成实例化未完成初始化的早期单例对象。
* singletonFactories中存放的是ObjectFactory对象，此对象的getObject方法返回值即刚完成实例化还未开始初始化的单例对象。
* 它们的先后顺序是，**单例对象先存在于singletonFactories中，后存在于earlySingletonObjects中，最后初始化完成后放入singletonObjects中**。

## 项目

### 项目中如何支撑高并发的？

项目中应用的是分布式架构支撑的，通过redis集群构建项目的缓存层；前端到服务之间是使用的zookeeper集群+dubbo微服务的方式进行调用；项目架构采用的是前后端分离的方式，将静态文件放在nginx服务器集群上；数据库层面使用的是DB2数据库，还有部分项目使用的MySQL数据库等。



## MySQL

### MySQL的索引结构？

MySQL的索引结构使用的B+树，什么是B+树？说起B+树就要说什么是B树？说B树就要说什么是平衡二叉树？然后B+树对比B树的有点是什么？主要优点是查询速度快，查询相对稳定，速度接近于二分查找，因为所有的关键在存在叶子节点上，且节点的从左到右保持有序性。对比哈希索引，B+树支持区间查询；对比B树，B+树的中间节点不会保存子节点的指针，可以保存更多的关键字信息，且B+树的叶子节点的末尾节点会存在指针指向下一个叶子节点的头节点，使之成为一个有序的链表结构。

### 创建索引时需要考虑哪些因素？哪些字段可以作为索引字段？

1. 选择不为null的字段作为索引字段；
2. 被频繁查询的字段；
3. 被作为条件查询的字段；
4. 频繁需要排序的字段；
5. 被经常频繁用于连接的字段；
6. 被频繁更新的字段应该慎用创建索引；
7. 尽量考虑建立联合索引而不是单列索引；
8. 避免冗余索引；
9. 考虑在字符串类型的字段上使用前缀索引代替普通索引。

### 使用索引时需要注意什么？

使用索引时，避免违反最左匹配原则；

1. 遇到范围查询（如>,<,between,like）等会停止匹配
2. or连接索引失效
3. 使用order by或group by时，是否违反最左匹配原则，违反最左前缀法则，导致额外的文件排序（会降低性能）

## 设计模式

### 单例模式双重检验锁 为什么要双重校验？

双锁模式指在懒汉模式的基础上做进一步优化，给静态对象的定义加上volatile锁来保障初始化时对象的唯一性，在获取对象时通过synchronized (Singleton.class)给单例类加锁来保障操作的唯一性。

## 计算机网络

### TCP和UDP的区别？

* TCP：有连接；可靠的；面向字节流；全双工通信，TCP两端既可以作为发送端也可以作为接收端；连接的两端只能是两个端点，即一对一，不能一对多。
* UDP：无连接；不可靠；面向报文；咩有拥塞控制，始终以恒定速率发送数据；支持一对一、一对多、多对多、多对一等。

### TCP是如何保证数据可靠性的？

* 数据分块传输；
* TCP发送发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层；
* 校验和：TCP首部和数据的校验和。
* TCP的接收端会丢弃重复的数据。
* 流量控制
* 拥塞控制
* 超时重传

### 在浏览器输入一个URL（如www.baidu.com）后执行的全部过程

* 1、浏览器查找域名的IP地址；（DNS查找过程：浏览器缓存、路由器缓存、DNS缓存）
* 2、浏览器向web服务器发送一个HTTP请求；（cookies会随着请求发送给服务器）
* 3、服务器处理请求；（请求 处理请求 & 它的参数、cookies、生成一个HTML响应）
* 4、服务器发回一个HTML响应
* 5、浏览器开始显示HTML

其中 1 步中 涉及DNS：获取域名对应的IP

2-5步中 涉及 TCP：与服务器建立TCP连接（3次握手）；IP：建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议；OSPF：IP数据包在路由器之间，路由选择使用OSPF协议；ARP：路由器在与服务器通信时，需要将IP地址转换为MAC地址，需要使用ARP协议；HTTP协议：在TCP建立完成后，使用HTTP协议访问网页。

小结：

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

## 中间件

### Redis

#### 五种数据类型

字符串、列表、集合、有序集合、Hash

#### 有序集合的底层数据结构

有序集合使用跳表的数据结构来实现的。

#### Redis如何保证高可用的



### Dubbo



### Zookeeper



### Kafka

