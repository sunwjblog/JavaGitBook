# 第一节 Java并发编程基础

#### 1.1线程简介

##### 1.1.1什么是进程？什么是线程？

​		在我们日常的使用的电脑操作系统运行一个程序时，会为其创建一个进程。例如，我们启动一个微信应用程序，操作系统会就会创建一个微信进程。

​		在现代的操作系统调度的最小单位是线程，又名轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都有各自的计数器、虚拟机栈和本地方法栈，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。

##### 1.1.2为什么要使用多线程？

​		正确的使用多线程，能够给开发人员带来显著的好处，使用多线程的主要原因是提高任务的处理效率。

​		随着处理器上的核心数量越来越多，我们已经告别了单核时代，步入到了多核时代，多核时代多线程主要为了提高处理器的利用率。例如，我们要计算一个逻辑复杂的任务，我们只用一个线程去处理，处理器只会一个核心被利用到，而创建多线程就可以让多个处理器核心被利用。

##### 1.13线程的生命周期

​		Java线程在运行的生命周期中会有6中不同的状态变化，在某个时刻，线程只能处于其中的一个状态。这6个状态分别是：NEW（初始状态）、RUNNABLE（运行状态）、BLOCKED（阻塞状态）、WAITING（等待状态）、TIME_WAITING（超时等待状态）、TERMINATED（终止状态）。



这6个状态的状态流转图如下：

![img](/Users/sunwj/Documents/GitHub/JavaGitBook/image/线程生命周期图.png)



​			从图中可以看出来，在new一个线程对象时，线程处于初始状态；当调用start()方法时，线程处于运行状态；执行线程中的run()方法时，线程处于运行中的状态；随后由于各种的阻塞线程、中断线程等操作，使线程处于等待状态、超时等待状态、阻塞状态等；最后线程执行完或执行过程中抛异常，则线程处于终止状态。

#### 1.2启动线程和实现方式

##### 1.2.1实现多线程的方式有那几种

​		实现多线程的方式有3种，第一种是继承Thread类的方式；第二种是继承Runnable接口的方式；第三种使用线程池的方式。其中在项目中建议使用线程池的方式使用多线程，并且要自己根据服务器的配置情况，创建一个线程池，不允许使用Executors去创建。

​		在阿里巴巴开发手册上，也是建议大家使用线程池的方式创建多线程，如：

![线程池约束](/Users/sunwj/Documents/GitHub/JavaGitBook/image/线程池约束.png)

##### 1.2.2启动线程

​		线程对象在初始化完成之后，调用start()方法就可以启动这个线程，线程start()方法的含义：当前线程同步告知Java虚拟机，只有线程规划器空闲，应立即启动调用start()方法的线程。

​		在启动线程前，最好为这个线程设置线程名称，方便在排查问题时，会给开发人员一些提示，定位问题。

**为什么调用start()方法时会执行run()方法，不能直接调用run()方法？**

​		new 一个 Thread，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。

​		直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

​		调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。

##### 1.2.3什么是中断

​		中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其它线程进行了中断操作。就好比其他线程对该线程打了一个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。

​		线程通过检查自身是否被中断来进行响应，线程通过isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如果该线程已经是终止状态了，则即使该线程被中断过，调用该线程对象的isInterrupted()时依然返回false。

​		在Java的API中有许多声明跑车InterruptedException的方法（如Thread.sleep()方法），这些方法在抛出异常之前，Java虚拟机先将该线程的中断标识位清除了，然后在抛出异常，此时调用isInterrupted()方法将会返回false。