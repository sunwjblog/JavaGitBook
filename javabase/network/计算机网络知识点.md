

# 计算机网络知识

### 1、OSI参考模型，TCP/IP协议，五层协议体系结构

![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/计算机网络OSI.png)

​	**各层的封装过程：**

​	![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/OSI各层封装过程.png)

* ##### 1.1 OSI分层（7层）

  * 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

* ##### 1.2 TCP/IP分层（4层）

  * 网络接口层、网际层、运输层、应用层。

* ##### 1.3 五层协议（5层）

  * 物理层、数据链路层、网络层、运输层、应用层。

* ##### 每一层的协议

  * 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）
  * 数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）
  * 网络层：**`IP（重点关注）`**、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）
  * 传输层：**`TCP、UDP（重点关注）`**、SPX
  * 会话层：NFS、SQL、NETBIOS、RPC
  * 表示层：JPEG、MPEG、ASII
  * 应用层：FTP、DNS、Telnet、SMTP、**`HTTP（重点关注）`**、WWW、NFS

* ##### 每一层的作用

  * **物理层：**通过媒介传输比特,确定机械及电气规范（比特Bit）
  * **数据链路层**：将比特组装成帧和点到点的传递（帧Frame）
  * *网络层：负责数据包从源到宿的传递和网际互连（包PackeT）（重点关注）*
  * *传输层：提供端到端的可靠报文传递和错误恢复（段Segment）（重点关注）*
  * **会话层**：建立、管理和终止会话（会话协议数据单元SPDU）
  * **表示层**：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
  * **应用层**：允许访问OSI环境的手段（应用协议数据单元APDU）

### 2、TCP三次握手四次挥手

* #### 三次握手

  * 第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND（发送）状态，等待服务器确认；
  * 第二次握手：服务器收到syn包，必须确认客户端的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（接收）状态；
  * 第三次握手：客户端收到服务器的SYN_ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（已建立）状态，完成三次握手。

  ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/TCP三次握手时序图.png)

  

  ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/TCP三次握手.png)

  解释：

  ​	SYN和ACK是标志位（0/1）（ACK=1表明ack有效），seq是序列号，ack是确认号。

  ​	给对方的确认方式就是把对方传来的seq+1并赋给ack。

* #### 四次挥手

  * 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
  * 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1。
  * 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
  * 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

  ![](/Users/sunwj/Documents/GitHub/JavaGitBook/image/TCP四次挥手时序图.png)

* #### TCP为什么会采用三次握手？

  * TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。
  * 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。场景：**主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。**

* #### TCP为什么需要四次挥手？

  * 因为TCP是全双工通信，服务端和客户端都能发送和接收数据；TCP在断开连接时，需要服务端和客户端都确定对方将 不发送数据。
  * 比如当被动方收到主动方的FIN报文通知时，它仅代表主动方没有数据发送给被动方了；
  * 但不代表被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET，它可能还需要发送一些数据给主动后，再发送FIN报文给主动方，通知主动方同意关闭。
  * 所以这里的ACK报文和FIN报文多数情况下都是分开发送的。

* #### 为什么会有TIME_WAIT状态

  * 确保有足够的时间让对方收到ACK包

  * 避免新旧连接混淆

    如果client直接closed，然后又向server发起了一个新连接，我们不能保证这个新连接和刚关闭的连接的端口号是不同的。

    假设新连接和已经关闭的老端口号是一样的，如果前一次滞留的某些数据仍然在网络中，这些延迟数据会在新连接建立后到达Server，所以socket就认为那个延迟的数据是属于新连接的，数据包就会发生混淆

### 3、在浏览器输入一个URL（如www.baidu.com）后执行的全部过程

1. 客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。
2. 客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。
3. 在客户端的**传输层(添加TCP头)**，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
4. 客户端的**网络层（添加IP头）**不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
5. 客户端的**链路层（添加MAC头）**，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

### 4、TCP和UDP的区别

* **UDP（User Data Protocol）用户数据报协议**

  * 无连接
  * 不可靠（不能保证都送达）
  * 面向报文（UDP数据传输单位是报文，不会对数据进行拆分和拼接操作，只是给上层传来的数据加个UDP头或者给下层来的数据去掉UDP头）
  * 没有拥塞控制，始终以恒定速率发送数据
  * 支持一对一、一对多、多对多、多对一
  * 首部开销小，只有8字节

* **TCP（Transmission Control Protocol）传输控制协议**

  * 有连接
  * 可靠的
  * 面向字节流
  * 全双工通信，TCP两端既可以作为发送端也可以作为接收端
  * 连接的两端只能是两个端点，即一对一，不能一对多
  * 至少20个字节，比UDP大的多

* **什么是TCP连接**

  TCP连接是一种抽象的概念，表示一条可以通信的链路。
  每个TCP连接有且仅有两个端点，表示通信的双方，且双方在任意时刻都可以作为发送者和接受者。

* **什么是套接字**

  一条TCP连接的两端就是两个套接字。

  套接字 = IP地址 ：端口号
  因此，TCP连接 = （套接字1，套接字2）= （IP1：端口号1，IP2：端口号2）

### 5、TCP 协议如何保证可靠传输

1. 应用数据被分割成 TCP 认为最适合发送的数据块。 
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 
4. TCP 的接收端会丢弃重复的数据。 
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### 6、滑动窗口和流量控制（了解）

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 7、拥塞控制（了解）

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。

拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。

相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.
-  **快重传与快恢复：**
   在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

### 8、ARQ协议（了解）

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。

#### 停止等待ARQ协议
停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。

在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

**优缺点：**

- **优点：** 简单
- **缺点：** 信道利用率低，等待时间长

**1) 无差错情况:**

发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。

**2) 出现差错情况（超时重传）:**

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。**连续 ARQ 协议** 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。

**3) 确认丢失和确认迟到**

- **确认丢失** ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。
- **确认迟到** ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。

#### 连续ARQ协议

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优缺点：**

- **优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。
- **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。