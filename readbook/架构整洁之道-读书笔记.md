# 架构整洁之道-读书笔记

[toc]

### 第1章 设计与架构究竟是什么

#### 笔记和所想

“架构”往往适用于“高层级”的讨论中。这类讨论一般都把“底层”的实现细节配出在外。

“设计”往往用来指代具体的**系统底层组织结构和实现的细节。**

用白话讲也就是，架构是搭架子，不考虑具体的细节实现；而设计是针对每个架构的细节更具体化的实现。

不论是是架构还是设计，两个都是软件架构的不可分割的两部分。

软件架构的目标是什么？文中提到，软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。

做过两三年开发的程序员，反复的读这句话，是不是开始的时候项目人员很多，随着项目的逐渐成熟稳定，是不是就人员越来越少了，这句话给出了原因。

当然也存在不乐观的情况，就是软件开始架构很好，随着新旧人员的替换、代码的不规范、业务的量叠加、开发时间短代码低质量开发等等原因，导致系统乱作一团。在工程师层面会造成的生产力会持续低下，在管理层面会造成维护成本越来越高等问题。

书中的例子说明，我们在日常做系统开发的时候，要想系统长久，先要让系统稳固的进行需求迭代。所以说**要想跑的快，先要跑的问。**

#### 小结

不论是从架构方面还是从设计方面来看，最终都脱离不了编码，最终落到编码上，作为工程师不能只完成需求开发，保证正常运行就可以了，除此之外，还要认真对待自己的代码架构，对其代码质量要负责。

要想提高自己软件架构的质量，就需要先知道什么是优秀的软件架构。而为了系统构建过程中采用好的设计和架构以便减少构建成本，提高生产力，又需要先了解系统架构的各种属性与成本和生产力的关系。

### 第2章 两个价值维度

#### 笔记和所想

每个软件系统，都可以通过行为和架构两个维度来体现它的实际价值。软件研发人员应该确保自己的系统在这两个维度上的实际价值能长时间维持在很高的状态。

##### 什么是行为价值？

行为价值简单来说，就是拿到需求开发，程序员开发完成，让机器按照某种业务指定方式运转，给系统的使用者创造或者提高利润。

比如我们在日常开发中，我们接到一个校园活动推广的需求开发，我们根据需求说明书开发功能点，然后进行测试上线，线上出现问题及时修复。运营推广给学生使用，给客户吸引来了用户并创造了利润，这些是软件系统的行为价值。

##### 什么是架构价值？

软件架构必须保持灵活，并且避免重复，提高更高的复用度。

当需求方改变需求的时候，随之所需的软件变更必须可以简单而方便的实现。变更实施的难度应该和变更的范畴成等比关系，而与变更的具体形状无关。

比如在我们需求迭代的开发过程中，不应该每个需求是独立的，而是与系统架构想兼容的，可以与系统架构中的某些部分抽取共用部分，减少不想干部分的交叉等，将每个需求的功能点细化不可在细化的功能，这样的话，涉及到不同业务交叉时，可以灵活的复用细化后的功能点。

##### 哪个价值维度更重要

至于这两个维度哪个更重要，没有绝对的答案，只能从不同的角度去看待这个问题。

对于业务部门来说的话，他们肯定认为系统正常运行很重要。对于系统开发人员来说的话，不应该与业务部门持相同的态度，应该是在保证系统正常运行的前提下，还可以很容易的修改它，并且随着需求的变化不停的修改它，也应该是一件很容易的事。

##### 艾森豪威尔矩阵

艾森豪威尔矩阵

| 重要且紧急   | 重要不紧急     |
| ------------ | -------------- |
| 不重要但紧急 | 不重要且不紧急 |

软件系统的第一个价值维度：系统行为，是紧急的，但是并不总是特别紧急。

软件系统的第二个价值维度：系统架构，是重要的，但是并不总是特别紧急。

在我们现实工作中，是不是业务部门与研发人员经常犯的共同错误就是将第三优先级的事情提到了第一优先级去做。换句话说，就是他们没有把真正紧急并且重要的功能和紧急但是不重要的功能分开。

这个错误导致了重要的事被忽略了，重要的系统架构问题让位给了不重要的系统行为功能。还有就是业务部门没有能力评估系统架构的重要程度，这本来就应该是研发人员自己的工作职责！所以，平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责。

回顾自己平时工作过程中，多少次都是以系统行为为重要且紧急的事情去处理，却忽略了作为一个研发人员的本职工作。你跟我是不是也犯了同样的错误？

##### 为好的软件结构而持续斗争

作为一名软件开发人员，应该要毫不掩饰地与所有其他的系统相关方进行平等的争吵。因为你也是相关者之一。软件系统的可维护行需要研发人员来保护，这是你工作的一部分，也是你职责中不可缺少的一部分。

所以当需求提出无理需求的时候，作为研发人员应该在需求的可行性上和对系统架构的影响性上与需求方进行分析，并最终给出最优的可行性方案。不能一昧的只知道接需求，然后直接上手进行编码。这样是不对的，是对自己不负责，也是对系统架构不负责，说大了也是对公司不负责。作为一个高级开发来说，你所写的代码行，影响程度，其实跟你的薪资是有一定关系的。当某一行出现bug，可能给公司带来的不可挽回的损失。

所以我们作为研发人员，一定要记住，一旦我们忽视了软件架构的价值，系统将会变得越来越难以维护，终会有一天，系统建辉变得再也无法修改。

如果最后成了这样，那只能说研发人员没有完成自己应尽的职责。

### 第3章 编程范式总览

#### 结构化编程

结构化编程对程序控制权的**直接转移**进行了限制和规范。

#### 面向对象编程

面向对象编程对程序控制权的**间接转移**进行了限制和规范。

#### 函数式编程

函数式编程对程序中的**赋值**进行了限制和规范。

这三个编程范式分别限制了goto语句、函数指针和赋值语句的使用。

#### 小结

这些编程范式与软件架构有着密切的关系，比如，多台式我们跨架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构话编程则是各模块的算法实现基础。

这和软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。

### 第4章 结构化编程

结构化编程范式中最优价值的地方就是，它赋予了我们创造可证伪程序单元的能力。这就是为什么现代编程语言一般不支持无限制的goto语句。

更重要的是，这也是为什么在架构设计领域，功能性降解拆分仍然是最佳实践之一。

无论在哪一个层面上，从最小的函数到最大组件，软件开发的过程都和科学研究非常相似，他们都是由证伪驱动的。比如我们平时做LeetCode算法题时，很多都是可以用科学公式进行推导的。软件架构需要定义可以方便进行证伪（测试）的模块、组件以及服务。

为了达到这个目的，他们需要将类似结构化编程的限制方法应用在更高的层面上。



测试只能展示Bug的存在，并不能证明不存在Bug。换句话说，一段程序可以由一个测试来证明其错误性，但是却不能被证明是正确的。测试的作用是让我们得出某段程序已经足够实现当前目标这一结论。



### 第5章 面向对象编程

做Java开发的，一看到面向对象编程，肯定会想到面向对象编程的3个特性，分别是封装、继承和多态。

面向对象编程是这三项的有机组合，或者任何一种支持面向对象编程语言必须支持这三个特性。

#### 封装

通过采用封装特性，我们可以把一组相关联的数据和函数圈起来，使圈外面的代码只能看见部分函数，数据则完全不可见。

通过例子说明，在很多方面面向对象编程语言对封装性并没有强制性的要求。

#### 继承

继承的主要作用就是让我们可以在某个作用域内对外部定义的某一组变量与函数进行覆盖。

面向对象编程在继承性方面并没有开创出新，但是在数据结构的伪装性上提供了相当程度的便利性。

#### 多态

多态其实是函数指针的一种应用。

用函数指针显示实现多态的问题在于函数指针的危险性。毕竟函数执政的调用依赖于一系列需要认为遵守的约定。如果程序员没有遵守这些约定，整个程序就会产生极其难以追踪和消除的Bug

面向对象编程语言消除了人工遵守的这些约定的必要，等于消除了这方面的危险性。采用面向对象编程语言让多态实现变得非常简单。

所以面向对象编程其实是对程序间接控制权的转移进行了约束。

### 第6章 函数式编程

### 第7章 SRP：单一职责原则

### 第8章 OCP：开闭原则

### 第9章 LSP：里氏替换原则

### 第10章 ISP：接口隔离原则

### 第11章 DIP：依赖反转原则

### 第12章 组件

### 第13章 组件聚合

### 第14章 组件耦合

### 第15章 什么是软件架构

### 第16章 独立性

### 第17章 划分边界

### 第18章 边界剖析

### 第19章 策略与层次 

### 第20章 业务逻辑

### 第21章 尖叫的软件架构

### 第22章 整洁架构

### 第23章 展示器和谦卑对象

### 第24章 不完全边界

### 第25章 层次与边界

### 第26章 Main组件

### 第27章 服务：宏观与微观

### 第28章 测试边界 

### 第29章 整洁的嵌入式架构 

### 第30章 数据库知识实现细节 

### 第31章 Web是实现细节 

### 第32章 应用程序框架是实现细节 

### 第26章 案例分析：视频销售网站

### 第34章 拾遗
